#!/bin/bash
set -euo pipefail

# ==============================================================================
# update.sh (single-dev safe mode)
#
# Design philosophy:
#   - Safe by default: ä½œæ¥­ä¸­ã§ã‚‚æ­¢ã‚ãšã«é€²ã‚ã‚‹ï¼ˆè‡ªå‹• wipï¼‰
#   - Explicit safety: --no-wip æŒ‡å®šæ™‚ã¯ä¸€åˆ‡è§¦ã‚‰ãªã„
#   - Reproducible: å‹•ã„ã¦ã„ãŸPR/commitã‚’å³ãƒ†ã‚¹ãƒˆå¯èƒ½
#
# ==============================================================================
# ===== Config =====
WORK_BRANCH="work/oldest-buildable-good"
REMOTE_NAME="origin"
WIP_PREFIX="wip(auto):"
PHONE_IP="10.5.5.3"
DEFAULT_PORT="40215"
VERBOSE=0

# ===== Logging =====
info() { echo "$*"; }
ok()   { echo "âœ… $*"; }
warn() { echo "âš ï¸  $*" >&2; }
die()  { echo "âŒ $*" >&2; exit 1; }

usage() {
  cat <<'EOF'
update.sh (single-dev safe mode)

Design philosophy:
  - Safe by default: ä½œæ¥­ä¸­ã§ã‚‚æ­¢ã‚ãšã«é€²ã‚ã‚‹ï¼ˆè‡ªå‹• wipï¼‰
  - Explicit safety: --no-wip æŒ‡å®šæ™‚ã¯ä¸€åˆ‡è§¦ã‚‰ãªã„ï¼ˆæ±šã‚Œã¦ã„ãŸã‚‰ä¸­æ–­ï¼‰
  - Reproducible: å‹•ã„ã¦ã„ãŸPR/commitã‚’å³ãƒ†ã‚¹ãƒˆå¯èƒ½

What is WIP / --no-wip ?
  - wip(auto): ä½œæ¥­ãƒ„ãƒªãƒ¼ãŒdirtyã§ã‚‚ã€ãƒ­ãƒ¼ã‚«ãƒ«ã«ä¸€æ™‚ã‚³ãƒŸãƒƒãƒˆã‚’ä½œã£ã¦å…ˆã¸é€²ã‚€å®‰å…¨ç­–
              ï¼ˆpushã—ãªã„ã€‚æˆ»ã™ãªã‚‰: git reset --soft HEAD~1ï¼‰
  - --no-wip : ä½œæ¥­ãƒ„ãƒªãƒ¼ãŒdirtyãªã‚‰â€œä½•ã‚‚ã—ãªã„ã§æ­¢ã¾ã‚‹â€æ…Žé‡ãƒ¢ãƒ¼ãƒ‰ï¼ˆäº‹æ•…é˜²æ­¢ï¼‰

Usage:
  ./update.sh                      # show help

Subcommands:
  ./update.sh update [options]      # fetch/pull WORK_BRANCH, then build+install
  ./update.sh switch [options]      # create/switch branch from PR or commit (optionally push & update WORK_BRANCH)
  ./update.sh test   [options]      # build/install test on temp branch (no detached), then return & cleanup

update options:
  --port|-p PORT        ADB connect port (default: 40215)
  --clean-install|-c    uninstall app before installDebug (requires device)
  --no-wip              abort if working tree dirty (default: auto WIP local commit)
  --dry-run             stop after fetch/pull (no gradle, no adb)
  --verbose|-v          show verbose logs (adb devices -l, etc.)

test options:
  --pr N | --commit SHA
  --build               run :app:compileDebugKotlin (default if neither --build nor --install)
  --install             run :app:installDebug (device required)
  --clean-install|-c    uninstall app before installDebug (requires --install)
  --port|-p PORT        ADB connect port (default: 40215)
  --keep-temp           keep temp branch after test (default: delete)
  --verbose|-v          show verbose logs (adb devices -l, etc.)

Examples:
  ./update.sh update --dry-run
  ./update.sh update --no-wip
  ./update.sh update -c --no-wip
  ./update.sh test --pr 398 --install -c -v

EOF
  exit 0
}

# ------------------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------------------

require_cmd() {
  local c="$1"
  command -v "$c" >/dev/null 2>&1 || die "Required command not found: $c"
}

ensure_git_repo() {
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not a git repository."
}

current_branch_or_die() {
  local b=""
  b="$(git symbolic-ref --short HEAD 2>/dev/null || true)"
  [[ -n "$b" ]] || die "Detached HEAD. Please switch to a branch first."
  echo "$b"
}

branch_exists_local() {
  local b="$1"
  git show-ref --verify --quiet "refs/heads/$b"
}

branch_exists_remote() {
  local b="$1"
  git show-ref --verify --quiet "refs/remotes/${REMOTE_NAME}/$b"
}

# Resolve PR number to commit hash by searching commit message containing "#<PR>"
# (works for messages like "... (#398)" or "... #398")
resolve_pr_to_commit() {
  local pr="$1"
  local sha=""
  sha="$(git log --grep "#${pr}\b" -n 1 --format=%H || true)"
  [[ -n "$sha" ]] || die "Could not resolve PR #$pr. Try: git log --grep \"#${pr}\""
  echo "$sha"
}

set_work_branch_in_script() {
  local new_branch="$1"
  local self="$0"
  [[ -f "$self" ]] || die "Script file not found: $self"
  sed -i -E 's|^([[:space:]]*WORK_BRANCH=)".*"|\1"'"$new_branch"'"|' "$self"
  ok "Updated WORK_BRANCH in script: $new_branch"
}

adb_connect_and_count() {
  local port="$1"
  info "Checking connected devices..." >&2
  adb connect "${PHONE_IP}:${port}" >/dev/null 2>&1 || true

  if [[ "${VERBOSE}" -eq 1 ]]; then
    adb devices -l >&2 || adb devices >&2 || true
  else
    # device list suppressed (use --verbose to show)
    :
  fi

  local cnt
  cnt="$(adb devices | awk 'NR>1 && $2=="device"{c++} END{print c+0}')"
  [[ "$cnt" =~ ^[0-9]+$ ]] || { echo "âŒ Device count is not numeric: $cnt" >&2; return 1; }
  echo "$cnt"
}

resolve_app_id() {
  # 1) build.gradle(.kts)
  if [[ -f app/build.gradle.kts ]]; then
    local id
    id=$(grep -E 'applicationId\s*=' -m1 app/build.gradle.kts | sed -E 's/.*applicationId\s*=\s*"([^"]+)".*/\1/' || true)
    if [[ -n "${id:-}" && "$id" != *applicationId* ]]; then
      echo "$id"; return 0
    fi
  fi
  if [[ -f app/build.gradle ]]; then
    local id
    id=$(grep -E 'applicationId\s+"[^"]+"' -m1 app/build.gradle | sed -E 's/.*applicationId\s+"([^"]+)".*/\1/' || true)
    if [[ -n "${id:-}" && "$id" != *applicationId* ]]; then
      echo "$id"; return 0
    fi
  fi

  # 2) merged manifest
  ./gradlew :app:processDebugMainManifest >/dev/null 2>&1 || ./gradlew :app:processDebugManifest >/dev/null 2>&1 || true

  local mf=""
  for p in \
    "app/build/intermediates/merged_manifest/debug/AndroidManifest.xml" \
    "app/build/intermediates/merged_manifests/debug/AndroidManifest.xml"
  do
    [[ -f "$p" ]] && mf="$p" && break
  done

  if [[ -n "$mf" ]]; then
    local id
    id=$(grep -Eo 'package="[^"]+"' -m1 "$mf" | sed -E 's/package="([^"]+)"/\1/' || true)
    if [[ -n "${id:-}" ]]; then
      echo "$id"; return 0
    fi
  fi

  # 3) apk (requires aapt)
  ./gradlew :app:assembleDebug >/dev/null 2>&1 || true
  local apk="app/build/outputs/apk/debug/app-debug.apk"
  if [[ -f "$apk" ]] && command -v aapt >/dev/null 2>&1; then
    local id
    id=$(aapt dump badging "$apk" | sed -n "s/package: name='\([^']*\)'.*/\1/p" | head -n1 || true)
    if [[ -n "${id:-}" ]]; then
      echo "$id"; return 0
    fi
  fi
  return 1
}

do_clean_uninstall_if_requested() {
  local clean="$1"
  if [[ "$clean" -ne 1 ]]; then return 0; fi

  info "Resolving applicationId..."
  local app_id=""
  if app_id="$(resolve_app_id)"; then
    ok "applicationId: $app_id"
    info "Uninstalling $app_id ..."
    adb uninstall "$app_id" >/dev/null 2>&1 || true
  else
    die "Could not resolve applicationId (clean install requested)."
  fi
}

maybe_auto_wip_commit() {
  local no_wip="$1"
  local auto_wip_commit_var="$2" # name of variable to set (bash indirection)

  if [[ -n "$(git status --porcelain)" ]]; then
    warn "Working tree is dirty."
    git status --short

    if [[ "$no_wip" -eq 1 ]]; then
      die "--no-wip is set. Aborting because working tree is dirty."
    fi

    info "Creating local WIP commit (no push)..."
    git add -A
    git commit -m "${WIP_PREFIX} before update.sh" >/dev/null
    printf -v "$auto_wip_commit_var" "1"
  else
    printf -v "$auto_wip_commit_var" "0"
  fi
}

guard_work_branch() {
  local cur
  cur="$(current_branch_or_die)"
  if [[ "$cur" != "$WORK_BRANCH" ]]; then
    die "Current branch is '$cur' (expected: '$WORK_BRANCH'). Edit WORK_BRANCH or use switch."
  fi
}

# ------------------------------------------------------------------------------
# Commands
# ------------------------------------------------------------------------------

cmd_update() {
  local port="$DEFAULT_PORT"
  local clean=0
  local no_wip=0
  local dry_run=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port|-p) port="${2:?Missing port}"; shift 2 ;;
      --clean-install|-c) clean=1; shift ;;
      --no-wip) no_wip=1; shift ;;
      --dry-run) dry_run=1; shift ;;
      --verbose|-v) VERBOSE=1; shift ;;
      --help|-h) usage ;;
      *) die "Unknown option for update: $1" ;;
    esac
  done

  require_cmd git
  ensure_git_repo
  guard_work_branch

  echo "ðŸ”§ update.sh (single-dev safe mode)"
  echo "ðŸ“¡ Target: ${PHONE_IP}:${port}"
  [[ "$clean" -eq 1 ]] && echo "ðŸ§¼ Clean install: ON (uninstall -> installDebug)"
  [[ "$dry_run" -eq 1 ]] && echo "Dry-run: ON (stop after fetch/pull)"

  local auto_wip_commit=0
  maybe_auto_wip_commit "$no_wip" auto_wip_commit

  info "Pulling latest changes..."
  git fetch "${REMOTE_NAME}" >/dev/null 2>&1 || true
  if git show-ref --verify --quiet "refs/remotes/${REMOTE_NAME}/${WORK_BRANCH}"; then
    git pull --ff-only "${REMOTE_NAME}" "$WORK_BRANCH"
  else
    warn "No remote branch ${REMOTE_NAME}/${WORK_BRANCH}. Skip pull."
  fi

  if [[ "$dry_run" -eq 1 ]]; then
    ok "dry-run completed (git fetch/pull only)."
    if [[ "$auto_wip_commit" -eq 1 ]]; then
      echo ""
      warn "NOTE: local WIP commit created: ${WIP_PREFIX} before update.sh"
      warn "Undo: git reset --soft HEAD~1"
    fi
    exit 0
  fi

  require_cmd adb
  [[ -x ./gradlew ]] || die "gradlew not found or not executable. Run from repo root."

  local device_count
  device_count="$(adb_connect_and_count "$port")"
  if [[ "$device_count" -lt 1 ]]; then
    warn "No device detected. Running assembleDebug only."
    ./gradlew :app:assembleDebug
    exit 0
  fi

  do_clean_uninstall_if_requested "$clean"

  info "Device detected ($device_count). Running installDebug..."
  ./gradlew :app:installDebug
  ok "update completed."

  if [[ "$auto_wip_commit" -eq 1 ]]; then
    echo ""
    warn "NOTE: local WIP commit created: ${WIP_PREFIX} before update.sh"
    warn "Undo: git reset --soft HEAD~1"
  fi
}

cmd_switch() {
  local pr=""
  local commit=""
  local branch=""
  local push=0
  local set_work=0
  local force=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --pr) pr="${2:?Missing PR number}"; shift 2 ;;
      --commit) commit="${2:?Missing commit sha}"; shift 2 ;;
      --branch|-b) branch="${2:?Missing branch name}"; shift 2 ;;
      --push) push=1; shift ;;
      --set-work-branch) set_work=1; shift ;;
      --force) force=1; shift ;;
      --help|-h) usage ;;
      *) die "Unknown option for switch: $1" ;;
    esac
  done

  require_cmd git
  ensure_git_repo
  git fetch -q "${REMOTE_NAME}" || true

  local base_commit=""
  if [[ -n "$pr" ]]; then
    base_commit="$(resolve_pr_to_commit "$pr")"
    info "Resolved PR #$pr -> $base_commit"
  elif [[ -n "$commit" ]]; then
    base_commit="$commit"
  else
    die "switch requires --pr N or --commit SHA"
  fi

  local shortsha
  shortsha="$(git rev-parse --short "$base_commit")"

  if [[ -z "$branch" ]]; then
    if [[ -n "$pr" ]]; then
      branch="work/from-pr-${pr}-${shortsha}"
    else
      branch="work/from-${shortsha}"
    fi
    info "Auto branch name: $branch"
  fi

  if branch_exists_local "$branch"; then
    if [[ "$force" -eq 0 ]]; then
      die "Local branch already exists: $branch (use --force to reuse/reset)"
    fi
    warn "Local branch exists; resetting it to $base_commit (--force)."
    git switch "$branch"
    git reset --hard "$base_commit"
  else
    info "Creating branch '$branch' from $base_commit"
    git switch -c "$branch" "$base_commit"
    ok "Created local branch: $branch"
  fi

  local remote_exists=0
  if branch_exists_remote "$branch"; then
    remote_exists=1
  fi

  if [[ "$push" -eq 1 ]]; then
    if [[ "$remote_exists" -eq 1 && "$force" -eq 0 ]]; then
      die "Remote branch already exists: ${REMOTE_NAME}/$branch (use --force to overwrite)"
    fi

    info "Pushing to ${REMOTE_NAME}..."
    if [[ "$remote_exists" -eq 1 && "$force" -eq 1 ]]; then
      warn "Overwriting remote branch with --force-with-lease: ${REMOTE_NAME}/$branch"
      git push --force-with-lease -u "${REMOTE_NAME}" "$branch"
    else
      git push -u "${REMOTE_NAME}" "$branch"
    fi
    ok "Remote branch ready: ${REMOTE_NAME}/$branch"
  else
    warn "Skipped push (--push not specified)."
    [[ "$remote_exists" -eq 1 ]] && warn "Note: remote already exists: ${REMOTE_NAME}/$branch"
  fi

  if [[ "$set_work" -eq 1 ]]; then
    set_work_branch_in_script "$branch"
  else
    info "WORK_BRANCH not changed (use --set-work-branch to update script)."
  fi

  echo ""
  ok "Branch prepared: $branch"
  echo "BRANCH_NAME=$branch"
}

cmd_test() {
  local pr=""
  local commit=""
  local port="$DEFAULT_PORT"
  local clean=0
  local do_build=0
  local do_install=0
  local keep_temp=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --pr) pr="${2:?Missing PR number}"; shift 2 ;;
      --commit) commit="${2:?Missing commit sha}"; shift 2 ;;
      --port|-p) port="${2:?Missing port}"; shift 2 ;;
      --clean-install|-c) clean=1; shift ;;
      --build) do_build=1; shift ;;
      --install) do_install=1; shift ;;
      --keep-temp) keep_temp=1; shift ;;
      --verbose|-v) VERBOSE=1; shift ;;   # â˜…å¯¾å¿œ1: testã§ã‚‚verboseæœ‰åŠ¹
      --help|-h) usage ;;
      *) die "Unknown option for test: $1" ;;
    esac
  done

  require_cmd git
  ensure_git_repo
  git fetch -q "${REMOTE_NAME}" || true

  [[ -x ./gradlew ]] || die "gradlew not found or not executable. Run from repo root."

  if [[ "$do_build" -eq 0 && "$do_install" -eq 0 ]]; then
    do_build=1
  fi

  if [[ "$clean" -eq 1 && "$do_install" -eq 0 ]]; then
    die "--clean-install requires --install (test mode)."
  fi

  local target_commit=""
  if [[ -n "$pr" ]]; then
    target_commit="$(resolve_pr_to_commit "$pr")"
    info "Resolved PR #$pr -> $target_commit"
  elif [[ -n "$commit" ]]; then
    target_commit="$commit"
  else
    die "test requires --pr N or --commit SHA"
  fi

  local shortsha
  shortsha="$(git rev-parse --short "$target_commit")"

  local orig_branch
  orig_branch="$(current_branch_or_die)"

  local tmp_branch
  if [[ -n "$pr" ]]; then
    tmp_branch="tmp/test-pr-${pr}-${shortsha}"
  else
    tmp_branch="tmp/test-${shortsha}"
  fi

  if branch_exists_local "$tmp_branch"; then
    die "Temp branch already exists: $tmp_branch (delete it or use another target)"
  fi

  info "Creating temp branch: $tmp_branch (from $target_commit)"
  git switch -c "$tmp_branch" "$target_commit"

  if [[ "$do_build" -eq 1 ]]; then
    info "Running compileDebugKotlin..."
    ./gradlew :app:compileDebugKotlin
    ok "build ok"
  fi

  if [[ "$do_install" -eq 1 ]]; then
    require_cmd adb
    local device_count
    device_count="$(adb_connect_and_count "$port")"
    [[ "$device_count" -ge 1 ]] || die "No device detected for install test."
    do_clean_uninstall_if_requested "$clean"
    info "Running installDebug..."
    ./gradlew :app:installDebug
    ok "install ok"
  fi

  info "Restoring original branch: $orig_branch"
  git switch -q "$orig_branch"

  if [[ "$keep_temp" -eq 1 ]]; then
    warn "Keeping temp branch: $tmp_branch (--keep-temp)"
  else
    info "Deleting temp branch: $tmp_branch"
    git branch -D "$tmp_branch" >/dev/null 2>&1 || true
  fi

  ok "test completed."
}

# ------------------------------------------------------------------------------
# Main
# ------------------------------------------------------------------------------

if [[ $# -lt 1 ]]; then
  usage
fi

cmd="$1"; shift || true
case "$cmd" in
  update) cmd_update "$@" ;;
  switch) cmd_switch "$@" ;;
  test)   cmd_test "$@" ;;
  --help|-h|help) usage ;;
  *)
    die "Unknown subcommand: $cmd (use: update|switch|test)"
    ;;
esac
